# LUCA
#
# Copyright (C) 2024 Genome Research Ltd.
#
# Author: Luca Barbon
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import logging
import os
import sys

import click
from pydantic import ValidationError

from .cli import common_cli_debug_options, common_cli_options
from .cli_utils import existing_file_path
from .codec import Codec
from .errors import CustomFileException
from .library_counts import CountFieldIndices, EmptyCountsFileError, MultiCombinationCounts, MultiDynamicLibraryCounts, MultiLibraryCounts, update_codec_from_counts, lib_count_field_indices, lib_indep_count_field_indices
from .manifest import OutputFileManifest
from .utils import has_duplicates, load_text_from_file, log_validation_error


HELP_VALIDATE_TARGETS = "Validate the target sequences when merging"
HELP_SKIP_MM_COUNTS = "Do not merge mismatching read library-independent counts"


def _merge_dynamic_count_files(fields: CountFieldIndices, fps: list[str]) -> MultiDynamicLibraryCounts | None:
    if not fps:
        return None

    mdlc = MultiDynamicLibraryCounts.from_counts_file(fields, fps[0])

    if len(fps) > 1:
        for fp in fps[1:]:
            mdlc.update_from_counts_file(fp)
    return mdlc


# TODO: have both commands [optionally also] as subcommands?
@click.command()
@click.argument('manifest', required=True, type=existing_file_path, nargs=-1)
@common_cli_options
@click.option('--validate-targets', is_flag=True, help=HELP_VALIDATE_TARGETS)
@click.option('--skip-mm-read-counts', is_flag=True, help=HELP_SKIP_MM_COUNTS)
@common_cli_debug_options
def merge(
    manifest: list[str],
    output: str,
    validate_targets: bool,
    skip_mm_read_counts: bool,
    loglevel: str
):
    """
    Merge counts across different runs and regenerate the statistics.

    MANIFEST: JSON manifest generated by the `count` subcommand
    """

    # Setup logger
    logging.basicConfig(
        level=logging._nameToLevel[loglevel.upper()],
        format="%(levelname)s: %(message)s")

    n = len(manifest)
    if n == 1:
        logging.warning("Please provide more than one manifest file path!")
        sys.exit(0)

    abs_paths = [
        os.path.abspath(fp)
        for fp in manifest
    ]
    if has_duplicates(abs_paths):
        logging.error("Duplicate manifest file paths!")
        sys.exit(1)
    root_dirs = [
        os.path.dirname(fp)
        for fp in abs_paths
    ]
    if has_duplicates(root_dirs):
        logging.error("Duplicate manifest root directories!")
        sys.exit(1)

    try:
        # TODO: merge global library-independent counts

        manifests = [
            (OutputFileManifest.model_validate_json(
                load_text_from_file(fp)), root_dir)
            for fp, root_dir in zip(abs_paths, root_dirs)
        ]

        first_manifest, _ = manifests[0]

        # Validate sample names
        sample_names = {
            m.sample_name
            for m, _ in manifests
        }
        sample_n = len(sample_names)
        match sample_n:
            case 0:
                logging.info("No sample name set in manifests.")
            case 1:
                pass
            case _:
                logging.error("Inconsistent sample name across manifests!")
                sys.exit(1)

        # Merge library-dependent counts
        logging.info("Merging library-dependent counts...")
        mlc = MultiLibraryCounts.from_manifest(*manifests[0])
        for m, root_dir in manifests[1:]:
            try:
                mlc.update_from_manifest(
                    m, root_dir, validate_sequences=validate_targets)
            except CustomFileException as ex:
                logging.error(ex.message)
                sys.exit(1)
        mlc.write(output)
        del mlc

        # Merge library-independent counts
        logging.info("Merging library-independent read counts...")
        mdlc = _merge_dynamic_count_files(lib_indep_count_field_indices, [
            os.path.join(root_path, m.library_independent_counts_file_path)
            for m, root_path in manifests
            if m.library_independent_counts_file_path
        ])

        if mdlc:
            mdlc.write_as_global(output)

        if not skip_mm_read_counts:

            # Merge library-independent mismatching read counts
            logging.info("Merging library-independent mismatching read counts...")
            mdlc = _merge_dynamic_count_files(lib_indep_count_field_indices, [
                os.path.join(root_path, m.library_independent_mm_counts_file_path)
                for m, root_path in manifests
                if m.library_independent_mm_counts_file_path
            ])

            if mdlc:
                mm = first_manifest.library_independent_mm_count_file_paths
                assert mm
                mdlc.write_as_global(output, sort=mm.is_sorted, prefix='mm', compress=mm.is_compressed)

        # Merge regional library-independent counts
        logging.info("Merging regional library-independent counts...")
        mdlc = _merge_dynamic_count_files(lib_count_field_indices, [
            os.path.join(root_path, m.dynamic_target_counts_file_path)
            for m, root_path in manifests
            if m.dynamic_target_counts_file_path
        ])

        if mdlc:
            mdlc.write_as_regional(manifests[0][0].library_count, output)

        cn = {
            len(m.combination_file_paths)
            for m, _ in manifests
        }

        if len(cn) == 0:
            sys.exit(0)

        if len(cn) > 1:
            logging.error("Inconsistent number of combination rules!")
            sys.exit(1)

        comb_n = cn.pop()

        codec = mdlc.codec if mdlc else Codec()
        m, root_dir = manifests[0]
        for lfp in m.library_file_paths.values():
            fp = os.path.join(root_dir, lfp.counts)
            # TODO: possibly enable validation once overlapping libraries are resolved
            update_codec_from_counts(codec, fp, validate_index=False)

        for ci in range(comb_n):
            mcc: MultiCombinationCounts | None = None
            for m, root_dir in manifests:
                cfp = m.combination_file_paths[ci]
                fp = os.path.join(root_dir, cfp.counts)
                if mcc is None:
                    mcc = MultiCombinationCounts(cfp.n)
                mcc.update_from_counts_file(fp)
            if mcc:
                mcc.write(ci, output)

    except ValidationError as ex:
        log_validation_error(ex)
        sys.exit(1)

    except EmptyCountsFileError as ex:
        logging.error(ex.message)
        sys.exit(1)
